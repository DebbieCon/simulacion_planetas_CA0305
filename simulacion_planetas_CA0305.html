<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Tu título</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="simulacion_planetas_CA0305_files/libs/clipboard/clipboard.min.js"></script>
<script src="simulacion_planetas_CA0305_files/libs/quarto-html/quarto.js"></script>
<script src="simulacion_planetas_CA0305_files/libs/quarto-html/popper.min.js"></script>
<script src="simulacion_planetas_CA0305_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="simulacion_planetas_CA0305_files/libs/quarto-html/anchor.min.js"></script>
<link href="simulacion_planetas_CA0305_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="simulacion_planetas_CA0305_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="simulacion_planetas_CA0305_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="simulacion_planetas_CA0305_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="simulacion_planetas_CA0305_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="simulacion_planetas_CA0305_files/libs/kePrint-0.0.1/kePrint.js"></script>

<link href="simulacion_planetas_CA0305_files/libs/lightable-0.0.1/lightable.css" rel="stylesheet">



</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Tu título</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introducción" class="level1">
<h1>Introducción</h1>
<p>El movimiento de los cuerpos celestes ha despertado un profundo interés durante siglos, tanto para la comunidad física como matemática. De hecho, ha sido impulsor de revoluciones científicas y filosóficas a lo largo de la historia. En sus inicios, los grandes pensadores centraban sus ideas en el movimiento de los cuerpos del sistema solar.</p>
<p>A lo largo del tiempo la discusión sobre el movimiento de los cuerpos celestes ha persistido, dando lugar a una variedad de teorías que en ocasiones se han mezclado y coexistido entre ellas. Desde la Teoría Geocéntrica formulada por Aristóteles y desarrollada por Ptolomeo, hasta la Teoría Heliocéntrica propuesta por Nicolás Copérnico en el siglo XVI y posteriormente confirmada por Galileo Galilei. Finalmente, la comunidad científica acepta el modelo Kepleriano que agrupa el heliocentrismo, las leyes de Kepler y las leyes de la mecánica establecidas por Newton <span class="citation" data-cites="Ponce2010">[@Ponce2010]</span>.</p>
<p>El problema de los dos cuerpos; es decir, el movimiento de dos masas que interactúan por la aceleración gravitacional puede ser descrita como una función de tiempo y es analíticamente soluble. Gracias a la mecánica clásica Newtoniana es posible describir el movimiento del sistema como una ecuación diferencial por tanto el problema se reduce a calcular las funciones que satisfacen estas ecuaciones <span class="citation" data-cites="Guzman2025">[@Guzman2025]</span>.</p>
<p>Este problema es de gran importancia en astronomía, mecánica orbital, dinámica galáctica, formación estelar, así como en la determinación de trayectorias óptimas para misiones de naves espaciales <span class="citation" data-cites="perezagua2022trescuerpos">[@perezagua2022trescuerpos]</span>.</p>
<p>Sin embargo, un sistema mayor a dos cuerpos no es analíticamente soluble por tanto no existe una solución explícita del sistema de ecuaciones. En el presente trabajo, se resolverá y simulará la trayectoria en dos cuerpos. Y además, en el caso tres cuerpos se realizará una aproximación con el método de Runge Kutta.</p>
</section>
<section id="exploración" class="level1">
<h1>Exploración</h1>
<p>El ser humano desde el inicio de los tiempos ha presentado cierta fascinación con el espacio. Desde las más antiguas civilizaciones el ser humano ha dedicado tiempo y esfuerzo en entender el movimiento de los cuerpos celestes desde una perspectiva filosófica, espiritual y científica. Primeramente, el interés de estas civilizaciones giraba en torno a las estrellas, lo que probó ser fundamental con el advenimiento de la navegación <span class="citation" data-cites="Ponce2010">[@Ponce2010]</span>.</p>
<p>Uno de los mayores quiebres en la teoría se produjo por Ptolomeo en el siglo II d.C, quien propuso que la Tierra ocupaba el centro del universo y los demás cuerpos giraban en órbitas alrededor de ella es decir, un modelo geocéntrico. Claramente, apoyándose con la teoría de Aristóteles; Teoría del geocentrismo. A pesar de no asemejarse a la realidad que conocemos probó ser bastante preciso en sus cálculos a la hora de predecir fenómenos astronómicos <span class="citation" data-cites="cortes2021aproximacion">[@cortes2021aproximacion]</span>.</p>
<p>Luego en el siglo XVI, Nicolás Copérnico plantea el Sol como el centro del universo, donde la tierra y demás cuerpos giraban alrededor de él; conocido como la teoría del heliocentrismo. La cual fue luego validada por Galileo usando el recién inventado telescopio <span class="citation" data-cites="Ponce2010">[@Ponce2010]</span>. A Galileo se le atribuye como el primero en utilizar el telescopio para el estudio sistemático de los cielos. Asimismo, se le considera “el padre de la ciencia” ya que sus descubrimientos contribuyeron a ponerle fin a la ciega lealtad a la autoridad tanto eclesiástica como a otros pensadores entre ellos Aristóteles, en materia de ciencia. Además, de promulgar la separación de la ciencia, religión y filosofía <span class="citation" data-cites="csic_galileo">[@csic_galileo]</span>.</p>
<p>Posteriormente, Johannes Kepler (1571-1630) postula las leyes de Kepler, conocidas como la Ley de las Órbitas, la Ley de las Áreas y la Ley de los Periodos. A partir de estas, Newton llega a ciertas conclusiones importantes. Una de ellas es que los planetas y los satélites no están en equilibrio; hay una fuerza neta que actúa sobre ellos ya que se mueven en órbitas (1era Ley del Movimiento). La segunda es que todos los cuerpos se atraen unos a otros mediante la fuerza gravitatoria, por lo tanto las fuerzas centrales sobre los planetas en el Sistema Solar es la atracción de la fuerza gravitatoria del Sol <span class="citation" data-cites="ibero2025kepler">[@ibero2025kepler]</span>.</p>
<p>Una vez que son postuladas y aceptadas las leyes de la mecánica desarrolladas por Newton en 1687, a las cuales también se les conoce como Leyes de Newton, la comunidad científica aprueba la Teoría Heliocéntrica y las las Leyes de Kepler. El modelo resultante de aplicar las leyes de Newton a un sistema con características similares al nuestro es lo que se conoce como el modelo Kepleriano <span class="citation" data-cites="Ponce2010">[@Ponce2010]</span>.</p>
<p>La mecánica clásica newtoniana permite describir el movimiento de los objetos mediante ecuaciones diferenciales. Estas ecuaciones basadas en las Leyes de Newton expresan cómo cambian las variables físicas como posición y velocidad en función del tiempo. Al resolver el sistema, se obtiene la trayectoria del mismo en cualquier instante. Por lo tanto, el comportamiento del sistema se reduce en calcular las funciones que satisfacen las ecuaciones. Ahora bien, encontrar las funciones mencionadas es sumamente complejo, inclusive para modelos simples. Los intentos de encontrar estas funciones se agrupan bajo el nombre del problema de los n cuerpos <span class="citation" data-cites="Ponce2010">[@Ponce2010]</span>.</p>
<p>Al tratarse de dos cuerpos, el sistema que consiste en las órbitas de dos masas que interactúan a causa de la aceleración gravitacional, el sistema es “analíticamente soluble”. Esto dado que el sistema se puede expresar como una ecuación diferencial y la función del movimiento entre las dos masas se puede describir usando las leyes de movimiento de Newton, junto con la fórmula de la fuerza gravitacional. Sin embargo, un sistema de tres o más masas interactuando exclusivamente por la aceleración gravitacional no es “analíticamente soluble” <span class="citation" data-cites="Guzman2025">[@Guzman2025]</span>.</p>
<p>La conclusión de que no es posible encontrar un función en el caso de tres cuerpos fue desarrollada por Henri Poincaré. Él determinó que en casos como el anterior la evolución del sistema es extremadamente caótica. Ya que, una pequeña perturbación en el estado inicial podría llevar eventualmente a un estado totalmente diferente. Por lo tanto, es imposible predecir el estado del sistema dado que los instrumentos de medición ni siquiera pueden detectar esa mínima variación <span class="citation" data-cites="pardo2022mecanica">[@pardo2022mecanica]</span>.</p>
<p>Poincaré más bien propone un estudio más cualitativo de las órbitas cuando se trata de esta cantidad o mayor cantidad de masas. Es así, que se establece una nueva área en la matemática; sistemas dinámicos <span class="citation" data-cites="Ponce2010">[@Ponce2010]</span>.</p>
</section>
<section id="metodología" class="level1">
<h1>Metodología</h1>
<p>Basado en lo expuesto en la introducción y la exploración, es pertinente plantear una metodología que permita darle una respuesta satisfactoria al problema planteado. En este caso, se pretende lograr tres objetivos principales: aproximación, simulación y animación. Como se explicó en la sección anterior, el problema de los dos cuerpos puede ser resuelto por completo de forma analítica, pero esto requeriría darle un enfoque al trabajo que no solo excede los alcances del curso, sino que se desvía de los aprendizajes esperados.</p>
<p>Por esta razón, para el problema de los dos cuerpos, la implementación se limitará a realizar una aproximación de la órbita, preferiblemente en un sistema bien conocido como Tierra-Sol, o de manera más general, de un cuerpo cuya masa pueda expresarse en términos del otro objeto en el sistema. Para abordar esta tarea, se puede crear una clase dedicada que, basada en los procedimientos propuestos por Alhowaity (2022), contenga un método que permita aproximar la solución al problema de los dos cuerpos, tomando como parámetros: tiempo inicial, tiempo final y los vectores de posición y velocidad iniciales. No obstante, para obtener estos valores es necesario realizar varios pasos previos, como el cálculo de los coeficientes requeridos para las series de potencias que se definen en el artículo previamente citado. Como resultado final de los métodos de esta clase, se espera obtener una tabla con los valores en cada coordenada (x,y,z) de los vectores de posición y velocidad del objeto a lo largo de un lapso establecido. Cabe destacar que un beneficio de realizar una aproximación y no buscar una solución exacta, es que queda margen para comparar los datos generados por el modelo con cifras de bases de datos reales, para así evaluar su porcentaje de error; esto será explorado en la implementación.</p>
<p>El segundo aspecto que se espera cubrir dentro de la implementación es la simulación. El primer paso debe ser la creación de una clase “Cuerpo”, que pueda representar un planeta, una estrella o cualquier otro objeto astronómico significativo, por lo que sus atributos deben necesariamente incluir su posición inicial (en tres dimensiones), su velocidad y su masa. A partir de esta primera clase madre, se puede desarrollar otra clase que se encargue de la simulación propiamente, para lo cual debería tener como atributo la lista de cuerpos (creados con la clase anterior) que van a interactuar y el tiempo que va a transcurrir en la simulación.</p>
<p>Ahora, para obtener los valores de posición y velocidad de los cuerpos a través del tiempo, se propone utilizar el Método de Runge-Kutta de cuarto orden (RK4), un método iterativo para la aproximación de soluciones a ecuaciones diferenciales. Este es relevante porque en el problema de los n-cuerpos, la posición y velocidad de cada cuerpo cambian con el tiempo por la influencia de las fuerzas gravitacionales de los demás, lo cual puede describirse mediante ecuaciones diferenciales. No solo ofrece soluciones para cada intervalo de tiempo establecido, sino que además utiliza un promedio ponderado de cuatro estimaciones de la pendiente de la solución para mejorar la precisión. Por lo tanto, es indispensable que la clase “Simulación” incorpore un método capaz de ejecutar el RK4 considerando varios cuerpos, para lo cual también es necesario un método auxiliar que calcule las aceleraciones y otro que actualice las posiciones de los cuerpos tras cada estimación.</p>
<p>Finalmente, se espera incluir una funcionalidad de animación dentro del código. Hasta el momento, los módulos anteriores solo muestran resultados numéricos o almacenan las operaciones internamente, pero para representar más intuitivamente su comportamiento se considera oportuno agregar módulos con la capacidad de mostrar gráficamente las trayectorias de los cuerpos en dos y tres dimensiones. Para esto, se incluirá una clase “Simulación2D” que herede de “Simulación”, la cual obtendrá los datos de las posiciones en el tiempo para dibujar las trayectorias con el uso de paquetes de graficación y animación como matplotlib.pyplot y matplotlib.animation. El principal método tendrá que definir de manera dinámica el rango de los ejes para garantizar la correcta visualización de todos los cuerpos, crear puntos que representan los cuerpos, líneas para trazar las trayectorias y actualizar periódicamente el gráfico mostrado para cubrir la órbita completa (o al menos en el periodo que se defina). De forma similar para la visualización en tres dimensiones, se construirá una clase “Simulación3D” con un funcionamiento análogo a su contraparte bidimensional, solo que con una coordenada adicional.</p>
</section>
<section id="implementación" class="level1">
<h1>Implementación</h1>
<p>Como se mencionó en la sección de Metodología, para el problema de los dos cuerpos se decidió aproximar la solución de la órbita y a la vez simularla. Aunque la solución de este problema existe tiene muchas variantes según cuales suposiciones iniciales se tomen, entre ellas la conservación de energía, de momento angular, deformaciones en espacio-tiempo, tiempo en actuar la fuerza gravitacional, entre otros <span class="citation" data-cites="helm2022approximate">[@helm2022approximate]</span>.</p>
<p>Para la aproximación de los dos cuerpos, se tomó como guía el artículo publicado por <span class="citation" data-cites="alhowaity2022twoBody">@alhowaity2022twoBody</span> donde utiliza series de potencias para aproximar la solución de las ecuaciones diferenciales. Se sigue el mismo método propuesto en el artículo con los 10 coeficientes de la suma debido a que obtener los siguientes resulta complejo y computacionalmente más demandante. Así en la clase SeriesAproximar.py se obtienen los coeficientes y las aproximaciones para una cantidad arbitraria de días, además como se mencionó en la metodología se usarán rangos pequeños de días por el uso de las ecuaciones diferenciales con delays o retrasos.</p>
<p>Con el polinomio ya calculado se crea un data frame en el que para cada día en el rango dado se genera una observación con un valor calculado de posición en las tres coordenadas y velocidad en las tres coordenadas. Con esto en el script de R denominado como LimpiezaDatos.R se carga la base de datos descargada en la página de la NASA denominada <a href="https://ssd.jpl.nasa.gov/horizons/app.html#/">Jet Propulsion Laboratory</a> donde se obtuvieron los datos de posición y velocidad para la Tierra tomando como observador el Sol, comenzando el día 01-04-2025 y terminando el 05-06-2025. El módulo de R proovee un breve código para leer la tabla y darle formato a la columna de fecha, además de seleccionar las columnas importantes. Es ahí donde en el script AnalisisDatos.R se toma esta base llamando el script LimpiezaDatos.R y la base de datos calculada llamando el script main.py, uniendo ambas tablas, calculando la norma de los vectores de posición y velocidad y generando los porcentajes de error.</p>
<div class="cell">
<div id="tbl-comparacion" class="cell quarto-float anchored">
<figure class="quarto-float quarto-float-tbl figure">
<div aria-describedby="tbl-comparacion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="cell-output-display">
<div class="table-responsive">
<table class="table table-striped table-hover do-not-create-environment cell table-sm small" data-quarto-postprocess="true">
<colgroup>
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th" style="text-align: center; empty-cells: hide; border-bottom: hidden;"></th>
<th colspan="3" data-quarto-table-cell-role="th" style="text-align: center; border-bottom: hidden; padding-bottom: 0; padding-left: 3px; padding-right: 3px; font-weight: bold;"><div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
Posicion (UA)
</div></th>
<th colspan="3" data-quarto-table-cell-role="th" style="text-align: center; border-bottom: hidden; padding-bottom: 0; padding-left: 3px; padding-right: 3px; font-weight: bold;"><div style="border-bottom: 1px solid #ddd; padding-bottom: 5px; ">
Velocidad (UA/dia)
</div></th>
</tr>
<tr class="odd">
<th data-quarto-table-cell-role="th" style="text-align: center; font-weight: bold; background-color: rgba(248, 249, 250, 255) !important;">Fecha</th>
<th data-quarto-table-cell-role="th" style="text-align: center; font-weight: bold; background-color: rgba(248, 249, 250, 255) !important;">Real</th>
<th data-quarto-table-cell-role="th" style="text-align: center; font-weight: bold; background-color: rgba(248, 249, 250, 255) !important;">Calculada</th>
<th data-quarto-table-cell-role="th" style="text-align: center; font-weight: bold; background-color: rgba(248, 249, 250, 255) !important;">Error</th>
<th data-quarto-table-cell-role="th" style="text-align: center; font-weight: bold; background-color: rgba(248, 249, 250, 255) !important;">Real</th>
<th data-quarto-table-cell-role="th" style="text-align: center; font-weight: bold; background-color: rgba(248, 249, 250, 255) !important;">Calculada</th>
<th data-quarto-table-cell-role="th" style="text-align: center; font-weight: bold; background-color: rgba(248, 249, 250, 255) !important;">Error</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center; font-weight: bold;">2025-04-01</td>
<td style="text-align: center;">0.99922</td>
<td style="text-align: center;">0.93917</td>
<td style="text-align: center; background-color: rgba(248, 249, 250, 255) !important;">6.01%</td>
<td style="text-align: center;">0.01722</td>
<td style="text-align: center;">0.35912</td>
<td style="text-align: center; background-color: rgba(248, 249, 250, 255) !important;">1985.25%</td>
</tr>
<tr class="even">
<td style="text-align: center; font-weight: bold;">2025-04-02</td>
<td style="text-align: center;">0.99951</td>
<td style="text-align: center;">0.93917</td>
<td style="text-align: center; background-color: rgba(248, 249, 250, 255) !important;">6.04%</td>
<td style="text-align: center;">0.01722</td>
<td style="text-align: center;">0.35912</td>
<td style="text-align: center; background-color: rgba(248, 249, 250, 255) !important;">1986.00%</td>
</tr>
<tr class="odd">
<td style="text-align: center; font-weight: bold;">2025-04-03</td>
<td style="text-align: center;">0.99979</td>
<td style="text-align: center;">0.93917</td>
<td style="text-align: center; background-color: rgba(248, 249, 250, 255) !important;">6.06%</td>
<td style="text-align: center;">0.01721</td>
<td style="text-align: center;">0.35912</td>
<td style="text-align: center; background-color: rgba(248, 249, 250, 255) !important;">1986.76%</td>
</tr>
<tr class="even">
<td style="text-align: center; font-weight: bold;">2025-04-04</td>
<td style="text-align: center;">1.00007</td>
<td style="text-align: center;">0.93917</td>
<td style="text-align: center; background-color: rgba(248, 249, 250, 255) !important;">6.09%</td>
<td style="text-align: center;">0.01720</td>
<td style="text-align: center;">0.35912</td>
<td style="text-align: center; background-color: rgba(248, 249, 250, 255) !important;">1987.55%</td>
</tr>
<tr class="odd">
<td style="text-align: center; font-weight: bold;">2025-04-05</td>
<td style="text-align: center;">1.00035</td>
<td style="text-align: center;">0.93917</td>
<td style="text-align: center; background-color: rgba(248, 249, 250, 255) !important;">6.12%</td>
<td style="text-align: center;">0.01720</td>
<td style="text-align: center;">0.35912</td>
<td style="text-align: center; background-color: rgba(248, 249, 250, 255) !important;">1988.34%</td>
</tr>
</tbody><tfoot>
<tr class="odd">
<td style="text-align: center; padding: 0;"><span style="font-style: italic;">Elaboración propia con datos reales de:</span> <sup></sup> NASA/JPL Horizons System</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tfoot>

</table>
</div>


</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-tbl" id="tbl-comparacion-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Tabla&nbsp;1: Comparacion entre valores calculados y reales: Posicion y velocidad de la Tierra con respecto al Sol
</figcaption>
</figure>
</div>
</div>
<p>En la anterior tabla se puede apreciar un pequeño análisis en el porcentaje de error tanto de la posición del cuerpo como de la velocidad, los detalles de este serán mencionados en el FODA.</p>
<p>Posteriormente con la clase Cuerpo.py mencionada en la metodología se instanciaron las características del objeto astronómico, posición inicial, velocidad inicial y masa, note que tanto el vector de posición como de velocidad acepta tanto de 2 o 3 coordenadas. Una vez instanciados los objetos tipo Cuerpo, la clase Simulacion_N_Cuerpos.py recibe una lista de ellos para los cuales calcula sus trayectorias aplicando el método de Runge Kutta de orden 4, esto lo hace con un tiempo de paso definido y recalculando su aceleración y posición con los métodos auxiliares programados en la misma clase. Con esto, el último método llamado simular genera un bucle con el tiempo de pasos definidos para crear un ‘gif’ con la simulación. En este apartado, es importante considerar que si se coloca un parámetro ‘h’ muy alto puede que en la simulación no se aprecie, o la aceleración y trayectorias no sean las esperadas. Esto se debe a que con un paso muy grande en el método de Runge Kutta el cálculo del nuevo punto por el que pasa el cuerpo será muy lejos del anterior punto demarcado, haciendo que el factor de la distancia entre cuerpos sea insignificante en el cálculo.</p>
<p>La clase Simulacion_2D.py propone un método que junto con los módulos mencionados en la metodología (matplotlib.pyplot y matplotlib.animate) es capaz de crear ejes dinámicos, que se ajustan según las posiciones iniciales de los cuerpos y una animación donde se aprecie el movimiento de los planetas. A su vez se tiene un método para guardar la animación como un gif.</p>
<p>La clase Simulacion_3D.py propone un método similar, solo que considerando un plano con 3 dimensiones, pero siguiendo la misma dinámica que Simulacion_2D.</p>
</section>
<section id="análisis-foda" class="level1">
<h1>Análisis FODA</h1>
<p>En la siguiente tabla se comentan las fortalezas, oportunidades, debilidades y amenazas identificadas en el desarrollo actual del proyecto:</p>
<table class="table">
<colgroup>
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
<col style="width: 25%">
</colgroup>
<thead>
<tr class="header">
<th>Fortalezas</th>
<th>Oportunidades</th>
<th>Debilidades</th>
<th>Amenazas</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Código bien estructurado, dividido en módulos con propósitos claros y que interactúan correctamente entre sí.</td>
<td>En el módulo SeriesAproximar, existe la posibilidad de agregar polinomios adicionales para mejorar la precisión del modelo en periodos de tiempo más extensos, pero la viabilidad de esto debe analizarse con mayor profundidad más adelante.</td>
<td>El módulo SeriesAproximar debe usarse con periodos cortos, ya que al depender de ecuaciones diferenciales con retraso, la aproximación para intervalos de tiempo más grandes puede resultar en márgenes de error considerables.</td>
<td>Al ser un sistema caótico, obtener datos reales con suficiente precisión para comparar simulaciones de más de dos cuerpos es complejo. lo que puede limitar la evaluación objetiva del modelo.</td>
</tr>
<tr class="even">
<td>Métodos y procedimientos con amplio respaldo bibliográfico y ejemplos pasados que demuestran su funcionamiento.</td>
<td>Se puede investigar y experimentar sobre técnicas para reducir el porcentaje de error de los resultados obtenidos con el modelo respecto a datos reales.</td>
<td>Con los métodos actuales, el porcentaje de error en los vectores de posición para un sistema Tierra-Sol está entre 6% y 6,4%, que es considerable.</td>
<td>El modelo es más simple y menos preciso que otras alternativas profesionales como REBOUND, que puede admitir muchos más parámetros iniciales, pero al costo de mayor exigencia computacional.</td>
</tr>
<tr class="odd">
<td>En general, se cumplen los objetivos planteados en la metodología: simulación y animación de sistemas de n-cuerpos, así como aproximación para un escenario de dos cuerpos.</td>
<td></td>
<td>Los porcentajes de error en los vectores de velocidad son aún mayores y, al menos por el momento, se desconoce cómo mejorarlos.</td>
<td></td>
</tr>
<tr class="even">
<td>Se logró comparar los datos obtenidos mediante el modelo con datos reales, lo que permitió conocer su margen de error.</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<div style="page-break-after: always;"></div>
</section>
<section id="anexos" class="level1">
<h1>Anexos</h1>
<p>Repositorio de GitHub : <a href="https://github.com/DebbieCon/simulacion_planetas_CA0305/blob/main/simulacion_planetas_CA0305.qmd" class="uri">https://github.com/DebbieCon/simulacion_planetas_CA0305/blob/main/simulacion_planetas_CA0305.qmd</a></p>
</section>
<section id="referencias" class="level1">
<h1>Referencias</h1>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiado");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiado");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>